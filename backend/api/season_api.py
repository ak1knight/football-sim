"""
Season management API for the football simulation engine.

Provides REST API endpoints for season management, scheduling,
standings tracking, and game result processing using database storage.
"""

from typing import Dict, List, Optional, Any
import logging
from flask import current_app

from database.connection import get_db_manager
from database.dao import SeasonDAO, SeasonTeamDAO, SeasonGameDAO, TeamDAO

from .season_formatters import (
    format_season_summary,
    format_season_details,
    format_game,
    format_team_record,
)
from .season_services import (
    generate_season_schedule,
    get_team_season_info,
    get_season_game_count,
    get_completed_game_count,
)

class SeasonAPI:

    def _verify_season_access(self, season_id: str, user_id: str) -> bool:
        """Verify that user has access to the season."""
        try:
            db_manager = get_db_manager()
            if not db_manager:
                return False
            season_dao = SeasonDAO(db_manager)
            season = season_dao.get_by_id(season_id)
            return season is not None and str(season['user_id']) == str(user_id)
        except Exception:
            return False
    """
    REST API for season management using database storage.
    
    Handles season creation, game scheduling, result processing,
    and standings queries with persistent database storage.
    """
    
    def __init__(self):
        """Initialize the Season API."""
        # Use Flask's app logger via current_app in methods
        self.logger = None  # Deprecated, use current_app.logger instead
    
    def create_season(self, user_id: str, season_name: str, season_year: int = 2024,
                     selected_teams: Optional[List[str]] = None) -> Dict[str, Any]:
        """
        Create a new season for a user.
        Returns: Dict[str, Any]: Season creation confirmation and initial status.
        """
        try:
            db_manager = get_db_manager()
            if not db_manager:
                return {"success": False, "error": "Database connection not available"}
            season_dao = SeasonDAO(db_manager)
            season_team_dao = SeasonTeamDAO(db_manager)
            team_dao = TeamDAO(db_manager)

            # Get teams to include in season

            if selected_teams:
                teams = [team_dao.get_by_id(tid) for tid in selected_teams]
            else:
                # Use get_all() for all teams
                teams = team_dao.get_all()
            # Remove None teams (in case of bad IDs)
            teams = [t for t in teams if t]
            if len(teams) < 2:
                return {'success': False, 'error': 'At least two teams required'}

            # Convert to Team objects (if needed)
            from models.team import Team
            def dict_to_team(t):
                if isinstance(t, Team):
                    return t
                # Accept dicts with required keys
                keys = ['name', 'city', 'abbreviation', 'conference', 'division']
                if all(k in t for k in keys):
                    return Team(
                        name=t['name'],
                        city=t['city'],
                        abbreviation=t['abbreviation'],
                        conference=t['conference'],
                        division=t['division']
                    )
                raise ValueError(f"Invalid team dict: {t}")
            team_objs = [dict_to_team(t) for t in teams]

            # Create engine and generate schedule (NFL by default)
            from simulation.season_engine import SeasonEngine
            from simulation.schedule_generators import NFLScheduleGenerator
            engine = SeasonEngine(
                teams=team_objs,
                season_year=season_year,
                schedule_generator=NFLScheduleGenerator()
            )

            # Create the season in DB
            season_id = season_dao.create_season(
                user_id=user_id,
                season_name=season_name,
                season_year=season_year,
                total_weeks=engine.schedule_generator.get_total_weeks(),
                current_week=engine.current_week,
                phase=engine.current_phase.value
            )

            # Add teams to season
            team_ids = [t['id'] if isinstance(t, dict) and 'id' in t else getattr(t, 'id', None) for t in teams]
            team_ids = [tid for tid in team_ids if tid]
            season_team_dao.bulk_add_teams_to_season(season_id, team_ids)

            # Store schedule in DB
            from database.dao import SeasonGameDAO
            season_game_dao = SeasonGameDAO(db_manager)
            games_data = []
            for g in engine.schedule:
                games_data.append({
                    'season_id': season_id,
                    'home_team_id': getattr(g.home_team, 'id', None),
                    'away_team_id': getattr(g.away_team, 'id', None),
                    'week': g.week,
                    'status': g.status.value,
                    'game_date': g.scheduled_date,
                    'home_score': g.home_score if g.home_score is not None else 0,
                    'away_score': g.away_score if g.away_score is not None else 0
                })
            season_game_dao.bulk_create_games(games_data)

            # Store team records in DB (update after bulk_add_teams_to_season if needed)
            # Optionally, update records for each team if engine.records has more info
            for abbr, record in engine.records.items():
                team = next((t for t in teams if (getattr(t, 'abbreviation', None) == abbr or t.get('abbreviation', None) == abbr)), None)
                if not team:
                    continue
                team_id = team['id'] if isinstance(team, dict) and 'id' in team else getattr(team, 'id', None)
                if not team_id:
                    continue
                season_team_dao.update_team_record(
                    season_id=season_id,
                    team_id=team_id,
                    wins=record.wins,
                    losses=record.losses,
                    ties=record.ties,
                    points_for=record.points_for,
                    points_against=record.points_against
                )

            return {
                'success': True,
                'message': f'Season "{season_name}" created successfully',
                'season': engine.to_db(),
                'total_teams': len(teams),
                'total_games': len(engine.schedule)
            }
        except Exception as e:
            current_app.logger.error(f"Error creating season: {str(e)}")
            return {
                'success': False,
                'error': f'Failed to create season: {str(e)}'
            }

    def get_user_seasons(self, user_id: str, active_only: bool = False) -> Dict[str, Any]:
        """
        Retrieve all seasons for a user.
        Returns: Dict[str, Any]: List of user's seasons.
        """
        try:
            db_manager = get_db_manager()
            if not db_manager:
                return {"success": False, "error": "Database connection not available"}
            season_dao = SeasonDAO(db_manager)
            seasons = season_dao.get_user_seasons(user_id, active_only=active_only)
            formatted_seasons = []
            for season in seasons:
                formatted_seasons.append(format_season_summary(season))
            return {
                'success': True,
                'seasons': formatted_seasons,
                'count': len(formatted_seasons)
            }
        except Exception as e:
            current_app.logger.error(f"Error getting user seasons: {str(e)}")
            return {
                'success': False,
                'error': f'Failed to get seasons: {str(e)}'
            }
    
    def get_season_status(self, season_id: str, user_id: str) -> Dict[str, Any]:
        """
        Get the current status of a season.
        Returns: Dict[str, Any]: Current season information and progress.
        """
        try:
            db_manager = get_db_manager()
            if not db_manager:
                return {"success": False, "error": "Database connection not available"}
            season_dao = SeasonDAO(db_manager)
            season = season_dao.get_by_id(season_id)
            if not season:
                return {'success': False, 'error': 'Season not found'}
            if str(season['user_id']) != str(user_id):
                return {'success': False, 'error': 'Unauthorized'}

            # Load teams, schedule, and records from DB (pseudo-code, adapt to your schema)
            if not season:
                return {'success': False, 'error': 'Season not found'}
            if not season:
                return {'success': False, 'error': 'Season not found'}
            season_with_teams = season_dao.get_season_with_teams(season_id)
            if not season_with_teams or 'teams' not in season_with_teams:
                return {'success': False, 'error': 'Season teams not found'}
            teams = season_with_teams['teams']
            from models.team import Team
            def dict_to_team(t):
                if isinstance(t, Team):
                    return t
                keys = ['name', 'city', 'abbreviation', 'conference', 'division']
                if all(k in t for k in keys):
                    return Team(
                        name=t['name'],
                        city=t['city'],
                        abbreviation=t['abbreviation'],
                        conference=t['conference'],
                        division=t['division']
                    )
                raise ValueError(f"Invalid team dict: {t}")
            team_objs = [dict_to_team(t) for t in teams]

            # Load schedule and records from DB
            from database.dao import SeasonGameDAO, SeasonTeamDAO
            season_game_dao = SeasonGameDAO(db_manager)
            season_team_dao = SeasonTeamDAO(db_manager)
            db_schedule = season_game_dao.get_season_games(season_id)
            db_records = season_team_dao.get_season_teams(season_id)
            completed_games = season_game_dao.get_completed_games(season_id)

            from simulation.season_engine import SeasonEngine
            from simulation.schedule_generators import NFLScheduleGenerator
            engine = SeasonEngine.from_db(
                teams=team_objs,
                season_year=season['season_year'],
                db_schedule=db_schedule,
                db_records=db_records,
                current_week=season['current_week'],
                current_phase=season['phase'],
                completed_games=completed_games,
                schedule_generator=NFLScheduleGenerator(),
                seed=season.get('seed')
            )

            return {
                'success': True,
                'season': engine.to_db(),
                'progress': engine.get_season_status()
            }
        except Exception as e:
            current_app.logger.error(f"Error getting season status: {str(e)}")
            return {
                'success': False,
                'error': f'Failed to get season status: {str(e)}'
            }
        try:
            db_manager = get_db_manager()
            if not db_manager:
                return {"success": False, "error": "Database connection not available"}
            if not self._verify_season_access(season_id, user_id):
                return {"success": False, "error": "Season not found or access denied"}
            season_dao = SeasonDAO(db_manager)
            season = season_dao.get_by_id(season_id)
            if not season:
                return {'success': False, 'error': 'Season not found'}
            if not season:
                return {'success': False, 'error': 'Season not found'}
            season_with_teams = season_dao.get_season_with_teams(season_id)
            if not season_with_teams or 'teams' not in season_with_teams:
                return {'success': False, 'error': 'Season teams not found'}
            teams = season_with_teams['teams']
            from models.team import Team
            def dict_to_team(t):
                if isinstance(t, Team):
                    return t
                keys = ['name', 'city', 'abbreviation', 'conference', 'division']
                if all(k in t for k in keys):
                    return Team(
                        name=t['name'],
                        city=t['city'],
                        abbreviation=t['abbreviation'],
                        conference=t['conference'],
                        division=t['division']
                    )
                raise ValueError(f"Invalid team dict: {t}")
            team_objs = [dict_to_team(t) for t in teams]
            # Load schedule and records from DB
            from database.dao import SeasonGameDAO, SeasonTeamDAO
            season_game_dao = SeasonGameDAO(db_manager)
            season_team_dao = SeasonTeamDAO(db_manager)
            db_schedule = season_game_dao.get_season_games(season_id)
            db_records = season_team_dao.get_season_teams(season_id)
            completed_games = season_game_dao.get_completed_games(season_id)
            from simulation.season_engine import SeasonEngine
            from simulation.schedule_generators import NFLScheduleGenerator
            engine = SeasonEngine.from_db(
                teams=team_objs,
                season_year=season['season_year'],
                db_schedule=db_schedule,
                db_records=db_records,
                current_week=season['current_week'],
                current_phase=season['phase'],
                completed_games=completed_games,
                schedule_generator=NFLScheduleGenerator(),
                seed=season.get('seed') if hasattr(season, 'get') else None
            )
            next_games = engine.get_next_games(limit=16)
            return {
                'success': True,
                'games': [g.to_dict() for g in next_games],
                'count': len(next_games)
            }
        except Exception as e:
            current_app.logger.error(f"Error getting next games: {str(e)}")
            return {
                'success': False,
                'error': f'Failed to get next games: {str(e)}'
            }
    
    def get_week_games(self, season_id: str, user_id: str, week: int) -> Dict[str, Any]:
        """
        Get all games for a specific week.

        Parameters:
            season_id (str): Season ID.
            user_id (str): User ID (for authorization).
            week (int): Week number (1-18 for regular season).

        Returns:
            Dict[str, Any]: List of games for the specified week.
        """
        try:
            db_manager = get_db_manager()
            if not db_manager:
                return {"success": False, "error": "Database connection not available"}
            if not self._verify_season_access(season_id, user_id):
                return {"success": False, "error": "Season not found or access denied"}
            season_dao = SeasonDAO(db_manager)
            season = season_dao.get_by_id(season_id)
            if not season:
                return {'success': False, 'error': 'Season not found'}
            season_with_teams = season_dao.get_season_with_teams(season_id)
            if not season_with_teams or 'teams' not in season_with_teams:
                return {'success': False, 'error': 'Season teams not found'}
            teams = season_with_teams['teams']
            from models.team import Team
            def dict_to_team(t):
                if isinstance(t, Team):
                    return t
                keys = ['name', 'city', 'abbreviation', 'conference', 'division']
                if all(k in t for k in keys):
                    return Team(
                        name=t['name'],
                        city=t['city'],
                        abbreviation=t['abbreviation'],
                        conference=t['conference'],
                        division=t['division']
                    )
                raise ValueError(f"Invalid team dict: {t}")
            team_objs = [dict_to_team(t) for t in teams]
            # Load schedule and records from DB
            from database.dao import SeasonGameDAO, SeasonTeamDAO
            season_game_dao = SeasonGameDAO(db_manager)
            season_team_dao = SeasonTeamDAO(db_manager)
            db_schedule = season_game_dao.get_season_games(season_id)
            db_records = season_team_dao.get_season_teams(season_id)
            completed_games = season_game_dao.get_completed_games(season_id)
            from simulation.season_engine import SeasonEngine
            from simulation.schedule_generators import NFLScheduleGenerator
            engine = SeasonEngine.from_db(
                teams=team_objs,
                season_year=season['season_year'],
                db_schedule=db_schedule,
                db_records=db_records,
                current_week=season['current_week'],
                current_phase=season['phase'],
                completed_games=completed_games,
                schedule_generator=NFLScheduleGenerator(),
                seed=season.get('seed') if hasattr(season, 'get') else None
            )
            week_games = engine.get_week_games(week)
            return {
                'success': True,
                'week': week,
                'games': [g.to_dict() for g in week_games],
                'count': len(week_games)
            }
        except Exception as e:
            current_app.logger.error(f"Error getting week games: {str(e)}")
            return {
                'success': False,
                'error': f'Failed to get week {week} games: {str(e)}'
            }
    
    def submit_game_result(self, season_id: str, user_id: str, game_id: str,
                          home_score: int, away_score: int, overtime: bool = False,
                          game_stats: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        Submit the result of a completed game.
        Parameters:
            season_id (str): Season ID.
            user_id (str): User ID (for authorization).
            game_id (str): Game ID.
            home_score (int): Home team score.
            away_score (int): Away team score.
            overtime (bool): Whether the game went into overtime.
            game_stats (Optional[Dict[str, Any]]): Additional game statistics.
        """
        try:
            db_manager = get_db_manager()
            if not db_manager:
                return {'success': False, 'error': 'Database unavailable'}
            if not self._verify_season_access(season_id, user_id):
                return {'success': False, 'error': 'Unauthorized'}

            # Update game result in DB
            season_game_dao = SeasonGameDAO(db_manager)
            updated = season_game_dao.update_game_result(game_id, home_score, away_score)
            if not updated:
                return {'success': False, 'error': 'Game not found or update failed'}

            # Load teams, schedule, and records from DB
            season_dao = SeasonDAO(db_manager)
            season = season_dao.get_by_id(season_id)
            if not season:
                return {'success': False, 'error': 'Season not found'}
            season_with_teams = season_dao.get_season_with_teams(season_id)
            if not season_with_teams or 'teams' not in season_with_teams:
                return {'success': False, 'error': 'Teams not found for season'}
            teams = season_with_teams['teams']
            from models.team import Team
            def dict_to_team(t):
                return Team(**t) if not isinstance(t, Team) else t
            team_objs = [dict_to_team(t) for t in teams]

            # Reload schedule and records from DB
            db_schedule = season_game_dao.get_season_games(season_id)
            from database.dao import SeasonTeamDAO
            season_team_dao = SeasonTeamDAO(db_manager)
            db_records = season_team_dao.get_season_teams(season_id)
            completed_games = season_game_dao.get_completed_games(season_id)

            from simulation.season_engine import SeasonEngine
            from simulation.schedule_generators import NFLScheduleGenerator
            engine = SeasonEngine.from_db(
                teams=team_objs,
                season_year=season['season_year'],
                db_schedule=db_schedule,
                db_records=db_records,
                current_week=season['current_week'],
                current_phase=season['phase'],
                completed_games=completed_games,
                schedule_generator=NFLScheduleGenerator(),
                seed=season.get('seed')
            )

            # Update engine with new result (to update in-memory standings)
            engine.process_game_result(game_id, home_score, away_score, overtime=overtime)

            # Update team records in DB
            for abbr, record in engine.records.items():
                db_dict = record.to_db_dict()
                season_team_dao.update_team_record(
                    season_id,
                    abbr,
                    db_dict['wins'],
                    db_dict['losses'],
                    db_dict.get('ties', 0),
                    db_dict.get('points_for', 0),
                    db_dict.get('points_against', 0)
                )

            # Optionally update season phase/week if needed
            season_dao.update_by_id(season_id, {
                'current_week': engine.current_week,
                'phase': engine.current_phase.value
            })

            return {
                'success': True,
                'message': 'Game result submitted and standings updated',
                'standings': engine.get_standings(),
                'season': engine.to_db()
            }
        except Exception as e:
            current_app.logger.error(f"Error submitting game result: {str(e)}")
            return {
                'success': False,
                'error': f'Failed to submit game result: {str(e)}'
            }
    
    def get_team_schedule(self, season_id: str, user_id: str, team_id: str) -> Dict[str, Any]:
        """
        Get the complete schedule for a specific team.
        Parameters:
            season_id (str): Season ID.
            user_id (str): User ID (for authorization).
            team_id (str): Team ID.
        Returns:
            Dict[str, Any]: Complete schedule for the team.
        """
        try:
            db_manager = get_db_manager()
            if not db_manager:
                return {"success": False, "error": "Database connection not available"}
            if not self._verify_season_access(season_id, user_id):
                return {"success": False, "error": "Season not found or access denied"}
            season_dao = SeasonDAO(db_manager)
            season = season_dao.get_by_id(season_id)
            if not season:
                return {'success': False, 'error': 'Season not found'}
            season_with_teams = season_dao.get_season_with_teams(season_id)
            if not season_with_teams or 'teams' not in season_with_teams:
                return {'success': False, 'error': 'Season teams not found'}
            teams = season_with_teams['teams']
            from models.team import Team
            def dict_to_team(t):
                if isinstance(t, Team):
                    return t
                keys = ['name', 'city', 'abbreviation', 'conference', 'division']
                if all(k in t for k in keys):
                    return Team(
                        name=t['name'],
                        city=t['city'],
                        abbreviation=t['abbreviation'],
                        conference=t['conference'],
                        division=t['division']
                    )
                raise ValueError(f"Invalid team dict: {t}")
            team_objs = [dict_to_team(t) for t in teams]
            from database.dao import SeasonGameDAO, SeasonTeamDAO
            season_game_dao = SeasonGameDAO(db_manager)
            season_team_dao = SeasonTeamDAO(db_manager)
            db_schedule = season_game_dao.get_season_games(season_id)
            db_records = season_team_dao.get_season_teams(season_id)
            completed_games = season_game_dao.get_completed_games(season_id)
            from simulation.season_engine import SeasonEngine
            from simulation.schedule_generators import NFLScheduleGenerator
            engine = SeasonEngine.from_db(
                teams=team_objs,
                season_year=season['season_year'],
                db_schedule=db_schedule,
                db_records=db_records,
                current_week=season['current_week'],
                current_phase=season['phase'],
                completed_games=completed_games,
                schedule_generator=NFLScheduleGenerator(),
                seed=season.get('seed') if hasattr(season, 'get') else None
            )
            # Use team abbreviation for lookup
            team_abbr = None
            for t in team_objs:
                if hasattr(t, 'id') and str(getattr(t, 'id')) == str(team_id):
                    team_abbr = t.abbreviation
                elif isinstance(t, dict) and t.get('id') == team_id:
                    team_abbr = t['abbreviation']
            if not team_abbr:
                return {'success': False, 'error': 'Team not found in season'}
            schedule = engine.get_team_schedule(team_abbr)
            return {
                'success': True,
                'team_id': team_id,
                'schedule': schedule,
                'total_games': len(schedule)
            }
        except Exception as e:
            current_app.logger.error(f"Error getting team schedule: {str(e)}")
            return {
                'success': False,
                'error': f'Failed to get team schedule: {str(e)}'
            }
